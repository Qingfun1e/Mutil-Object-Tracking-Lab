简单描述各个功能的设计思路，系统测试见演示视频，代码见github链接
#1.组件设计
##1.1帧捕捉模块
采用opencv的VideoCapture类来创建帧捕捉器对象，捕捉器的视频源可以是在线摄像头/IP摄像头或离线视频文件。通过帧捕捉器的read函数从cv2.mat矩阵获取一帧
##1.2目标检测模块
通过ultralyrics库快速调用YOLO模型，采用的是目前比较稳定的yolov8版本，模型选择的是s模型，yolov8s兼顾性能与效率。检测器对帧捕捉模块获取的视频帧做一次detection，得到该frame下的所有bounding box，通过简单的置信度阈值筛选掉置信度较低的bbox，每个frame检测出的bboxes包含cls，conf，xyxy三个tensor
##1.3追踪器模块
该追踪器主要是通过IoU阈值贪心来实现基于IoU贪心匹配的多目标追踪，我参考了论文《High-Speed Tracking-by-Detection Without Using Image Information》的追踪算法。
简单来说，每一个track被看成一个字典，包含ID, cls, boxes(xyxy)_list，conf_list, life_time, hit_cnt几个键值对。该算法会创建两个list，一个active_track，另一个是finished_track。每帧检测完得到的bboxes与上一帧位于active_list中每一track的boxes_list最后一个box（即上一帧被划入轨迹的box），计算IoU矩阵。通过torch.max来得到每一个track在这一帧的最佳bbox候选对象，若候选对象与某一track的最后一个box的IoU值大于设定的IoU阈值就判定该box为这个track在这一帧的延续，并将该box从这一帧的bboxes中移除；若不满足设定的IoU阈值则将该track的lifetime-1，当该track的lifetime为0则将其消灭，若消灭的轨迹hit_cnt>min_hit则将其加入finished_track中。对于未从bboxes的检测框将其创建为新的轨迹并丢入active_track中，以此往复直到视频帧被捕捉完。
##1.4可视化模块
可视化模块主要是对某一视频帧和该帧下追踪器中的active_track进行可视化，若其hit_cnt>min_hit就认定其为一条轨迹，将其检测框与ID,CLS,CONF信息绘制出来，并绘制FPS,PLAYSPEED与按键交互信息等内容
#2.多线程设计
##2.1核心思想
多目标追踪任务其实可以在线程管理上看成是一种生产者-消费者问题，视频帧捕捉线程是生产者，检测-追踪-绘制可以看成一个线程是消费者。对于临界区资源则是该视频帧，所以可以使用一个queue来实现两个线程之间的通信，视频帧捕捉线程不断将捕捉的帧传入frame_queue中，由于python中的queue库自带安全锁功能，可以无需额外加入锁机制来防止互斥。
##2.2相关细节
对于生产者线程而言，其主要职责是不断地将捕捉的帧送入frame_queue中，所以每当queue满了的时候，就自动地丢弃旧的frame，而消费者线程只需要不断地从frame_queue拿帧即可。即无需让生产者线程等消费者线程，而是让消费者线程通过一定的“跳帧”来跑满性能。
对于消费者线程即“检测-跟踪-可视化”三个模块组成，若将其进一步拆分成“检测-跟踪”与“可视化”两个进程就会需要另外一个queue来实现两个线程之间的“通信”，本身而言绘制模块所需的时延是比较短的（见下图）可以直接将这三个模块融合在一起，经过代码测试若另开一个队列会导致FPS下降5%。
##2.3多线程控制
对于多线程地控制方面，主要是使用标志字段来控制，如通过running字段来控制线程地启动，若主循环判断running为false则停止所有线程。
对于生产者线程其会不间断地捕捉帧，若其不再能捕捉帧，那应当停止该线程，而对于消费者线程而言其本身访问视频帧资源的速度是会远低于生产者捕捉帧的速度的.所以通过capture_finished标志来判定，当生产者线程完成的时候，将该标志字段置为1，一旦消费者线程不再能从frame_queue中拿到帧且该标志字段为1则将消费者线程关闭。这样就实现了各个线程直接的有序关停。
对于线程启动部分，若直接通过启动两个线程，因为消费者线程中的“YOLO检测器”模块每次运行时都需要编译CUDAkernel算子，所以会导致生产者线程启动后丢了一些帧，消费者线程才能开始正常运行，所以另外使用了warm_up字段来对启动的消费者线程预先进行一次模型推理，当预热完成后再正常运行系统
#3.交互设计
##3.1核心思想
由于可视化模型核心部分是通过"cv2.imshow"函数来实现的，该函数调用位于消费者线程中，所以将按键交互一并放于消费者线程中，对于暂停功能通过pause字段实现，将”视频帧捕捉“与“检测-跟踪-绘制”放于pause字段内（不同线程中均判断），从而不影响可视化与交互功能的正常使用。而按键交互则使用cv2.waitkey来捕捉不同的按键。
##3.2相关细节
暂停功能即按键检测到用户敲击空格时，将pause字段置反（初始为false），则生产者与消费者线程都会跳过pause字段下的代码块（即捕捉帧视频与“检测-追踪-绘制”）。
单步功能则通过step_forward字段控制，将其一起放到pause条件判断下。在暂停时才能使用单步功能，当用户按下D键时置1，处理一帧后置0。就实现了单步逻辑。
重置跟踪器ID功能即对tracker中的成员变量active_track和track_ID重置即可。
播放速度功能则通过对生产者线程中视频帧捕捉模块做调整，由于视频帧捕捉本身属于I/O操作其每帧获取所做的I/O操作时间是固定的，而控制播放速度其实是在控制每帧之间捕捉的间隔，通过动态的匹配控制帧与帧直接获取的时间间隔与当前FPS的关系即可实现播放速度控制
FPS计算则通过另外的一个deque来实现，计算近三帧的平均帧，单帧时间从消费者线程在frame_queue队列中获取视频帧开始，到绘制模块结束后停止。
